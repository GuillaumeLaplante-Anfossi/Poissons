Vertices of the arrangement:

def compl_part(X,Y,n): 
    return len(X)+len(Y) == n+1 and all([len(set(x).intersection(y)) <= 1 for x in X for y in Y]) and not any([all(set(x).issubset(z) or set(x).isdisjoint(z) for x in X) and all(set(y).issubset(z) or set(y).isdisjoint(z) for y in Y) for z in Subsets(range(n)) if len(z) != 0 and len(z) != n]) 

def V(n,k): return [(X,Y) for X in SetPartitions(range(n),k+1) for Y in SetPartitions(range(n), n-k) if compl_part(X,Y,n)]                                                                                                                   

def V(n): return [(X,Y) for X in SetPartitions(range(n)) for Y in SetPartitions(range(n), n+1-len(X)) if compl_part(X,Y,n)]                                                                                                                   

sage: [[len(V(n,k)) for k in range(n)] for n in range(1,7)]                                                                                                                                                                                 
[[1],
 [1, 1],
 [1, 6, 1],
 [1, 24, 24, 1],
 [1, 80, 270, 80, 1],
 [1, 240, 2160, 2160, 240, 1]]

u(n,k) = 1/(k+1)*binomial(n,k)*(k+1)^(n-1-k)*(n-k)^k                                                                                                                                                                                    

sage: [[u(n,k) for k in range(n)] for n in range(1,7)]                                                                                                                                                                                        
[[1],
 [1, 1],
 [1, 6, 1],
 [1, 24, 24, 1],
 [1, 80, 270, 80, 1],
 [1, 240, 2160, 2160, 240, 1]]


Facets of the arrangement:

sage: def D(n): return [(I,J) for k in range(1,n) for I in Subsets(range(1,n+1),k) for J in Subsets(set(range(1,n+1)).difference(I).difference(range(min(I))),k)]                                                                             

sage: def F(n): return [(s,t) for s in Permutations(n) for t in Permutations(n) if all([any([len(set(list(s)[:k]).intersection(I)) > len(set(list(s)[:k]).intersection(J)) or len(set(list(t)[:k]).intersection(I)) < len(set(list(t)[:k]).intersection(J)) for k in range(1,n)]) for (I,J) in D(n)])]                                                                                                                                                                                

sage: [len(F(n)) for n in range(1,6)]                                                                                                                                                                                                         
[1, 3, 17, 149, 1809]

sage: def P(n): return Poset(Permutations(n).weak_lattice(facade=True).hasse_diagram()).intervals_poset().subposet(F(n))

sage: var('x,y')                                                                                                                                                                                                                              
(x, y)
sage: taylor(exp(y*add([x^n*binomial(2*n,n)/((n+1)*n)for n in range(1,10)])), x, 0, 10)                                                                                                                                                       
1/3628800*(y^10 + 90*y^9 + 3720*y^8 + 93240*y^7 + 1572816*y^6 + 18668160*y^5 + 157342960*y^4 + 917046720*y^3 + 3387104064*y^2)*x^10 + 1/362880*(y^9 + 72*y^8 + 2352*y^7 + 45864*y^6 + 589008*y^5 + 5152896*y^4 + 30326896*y^3 + 111078432*y^2 + 196035840*y)*x^9 + 1/40320*(y^8 + 56*y^7 + 1400*y^6 + 20440*y^5 + 190288*y^4 + 1143968*y^3 + 4169520*y^2 + 7207200*y)*x^8 + 1/5040*(y^7 + 42*y^6 + 770*y^5 + 7980*y^4 + 50008*y^3 + 182616*y^2 + 308880*y)*x^7 + 1/720*(y^6 + 30*y^5 + 380*y^4 + 2580*y^3 + 9568*y^2 + 15840*y)*x^6 + 1/120*(y^5 + 20*y^4 + 160*y^3 + 620*y^2 + 1008*y)*x^5 + 1/24*(y^4 + 12*y^3 + 52*y^2 + 84*y)*x^4 + 1/6*(y^3 + 6*y^2 + 10*y)*x^3 + 1/2*(y^2 + 2*y)*x^2 + x*y + 1

sage: y = var('y', n=8, latex_name='y')                                                                                                                                                                                                       
sage: [expand(add([add(y[n]*x^n*binomial(2*n,n)/((n+1)*n)for n in range(1,8))^j/factorial(j) for j in range(7)])).collect(x).coefficients()[p][0]*factorial(p) for p in range(7)]                                                             
[1,
 y1,
 y1^2 + 2*y2,
 y1^3 + 6*y1*y2 + 10*y3,
 y1^4 + 12*y1^2*y2 + 12*y2^2 + 40*y1*y3 + 84*y4,
 y1^5 + 20*y1^3*y2 + 60*y1*y2^2 + 100*y1^2*y3 + 200*y2*y3 + 420*y1*y4 + 1008*y5,
 y1^6 + 30*y1^4*y2 + 180*y1^2*y2^2 + 200*y1^3*y3 + 120*y2^3 + 1200*y1*y2*y3 + 1260*y1^2*y4 + 1000*y3^2 + 2520*y2*y4 + 6048*y1*y5 + 15840*y6]

sage: HA3.<a,b,c> = HyperplaneArrangements(QQ)                                                                                                                                                                                                
sage: ha3 = HA3(a-b, a-c, b-c, a-b+1, a-c+3, b-c+2)                                                                                                                                                                                           
sage: len(ha3.regions())                                                                                                                                                                                                                      
17
sage: len([R for R in ha3.regions() if Polyhedron(ieqs=R.inequalities_list()+[[0,1,0,-1]]).dimension() == 3])                                                                                                                                 
5

sage: HA4.<a,b,c,d> = HyperplaneArrangements(QQ)                                                                                                                                                                                              
sage: ha4 = HA4(a-b, a-c, b-c, a-d, b-d, c-d, a-b+1, a-c+3, b-c+2, a-d+7, b-d+6, c-d+4)                                                                                                                                                       
sage: len(ha4.regions())                                                                                                                                                                                                                      
149
sage: len([R for R in ha4.regions() if Polyhedron(ieqs=R.inequalities_list()+[[0,1,0,0,-1]]).dimension() == 4])                                                                                                                               
40

sage: HA5.<a,b,c,d,e> = HyperplaneArrangements(QQ)                                                                                                                                                                                            
sage: ha5 = HA5(a-b, a-c, b-c, a-d, b-d, c-d, a-e, b-e, c-e, d-e, a-b+1, a-c+3, b-c+2, a-d+7, b-d+6, c-d+4, a-e+15, b-e+14, c-e+12, d-e+8)                                                                                                    
sage: len(ha5.regions())                                                                                                                                                                                                                      
1809
sage: len([R for R in ha5.regions() if Polyhedron(ieqs=R.inequalities_list()+[[0,1,0,0,0,-1]]).dimension() == 5])                                                                                                                             
454

# number of vertices in the convex hull of the vertices of the weird hyperplane arrangement: 4, 10, 32, 118


Intersections of the arrangement:

def partition_poset(n):
    return Poset((SetPartitions(range(n)),lambda q,p: q in p.refinements()), facade=True)

@cached_function
def intersection_poset(n):
    PP = partition_poset(n)
    PPP = cartesian_product((PP,PP), order='product')
    PPPP = Poset([list(PPP), lambda x, y: PPP.le_product(x,y)])
    A = [(X,Y) for (X,Y) in PPPP if compl_part(X,Y,n)]
    return PPPP.subposet(PPPP.directed_subset(A, direction='down'))

def partition_characteristic_polynomial(n):
    return add(prod(x * (-1)**(len(p)-1) * factorial(len(p)-1)  for p in P) for P in partition_poset(n))

Faces of the arrangement:

def number_faces(n,d):
    res = 0
    IP = intersection_poset(n)
    for F in IP:
        if len(F[0]) == n-d[0] and len(F[1]) == n-d[1]:
            ClF = Graph([list(range(n)), [(x,y) for p in F[0] for (x,y) in Subsets(p,2)] + [(x,y) for p in F[1] for (x,y) in Subsets(p,2)]])
            CC = ClF.connected_components()
            for G in IP.directed_subset([F], direction='up'):
                if all([G[0].restriction(cc) == F[0].restriction(cc) and G[1].restriction(cc) == F[1].restriction(cc) for cc in CC]):
                    res = res + prod(factorial(len(F[0].restriction(p))-1) for p in G[0]) * prod(factorial(len(F[1].restriction(p))-1) for p in G[1])
    return res

Same with k generically translated copies of the braid arrangement:

def intersection_graph(n, partitions):
    return Graph([((-1,i), (j,p)) for j in range(len(partitions)) for p in partitions[j] for i in p], format='list_of_edges')

@cached_function
def k_clique_forests(n,k):
    return [partitions for partitions in cartesian_product([SetPartitions(range(n))]*k) if intersection_graph(n, partitions).is_forest()]

def refines(partition1, partition2):
    return all(any(part1.issubset(part2) for part2 in partition2) for part1 in partition1)

@cached_function
def k_clique_forest_refinement_poset(n,k):
    return Poset([k_clique_forests(n,k), lambda F1, F2: all(refines(F1[i], F2[i]) for i in range(k))])

@cached_function
def refined_number_faces(n, dd):
    res = 0
    k = len(dd)
    FRP = k_clique_forest_refinement_poset(n,k)
    for F in FRP:
        if all(len(F[i]) == n-dd[i] for i in range(k)):
            for G in FRP.directed_subset([F], direction='up'):
                res = res + prod(factorial(len(F[i].restriction(p))-1) for i in range(k) for p in G[i])
    return res

def number_faces(n, k, d):
    return add([refined_number_faces(n, dd) for dd in IntegerVectors(d, length=k)])

@cached_function
def refined_number_bounded_faces(n, dd):
    res = 0
    k = len(dd)
    FRP = k_clique_forest_refinement_poset(n,k)
    for F in FRP:
        if all(len(F[i]) == n-dd[i] for i in range(k)):
            for G in FRP.directed_subset([F], direction='up'):
                res = res + prod(-factorial(len(F[i].restriction(p))-1) for i in range(k) for p in G[i])
    return abs(res)

def number_bounded_faces(n, k, d):
    return add([refined_number_bounded_faces(n, dd) for dd in IntegerVectors(d, length=k)])

def refined_characteristic_polynomial(n, dd):
    res = 0
    k = len(dd)
    FRP = k_clique_forest_refinement_poset(n,k)
    for F in FRP:
        if all(len(F[i]) == n-dd[i] for i in range(k)):
            for G in FRP.directed_subset([F], direction='up'):
                res = res + prod(y * (-1)**(len(F[i].restriction(p))-1) * factorial(len(F[i].restriction(p))-1) for i in range(k) for p in G[i])
    return res

def characteristic_polynomial(n, k, d):
    return add([refined_characteristic_polynomial(n, dd) for dd in IntegerVectors(d, length=k)])

HA3.<a,b,c> = HyperplaneArrangements(QQ)
ha3 = HA3(a-b, a-c, b-c)                                                                                                                                                                                 
u = random_vector(2, x=0, y=1000)
ha3b = HA3(a-b, a-c, b-c, a-b+u[0], a-c+u[0]+u[1], b-c+u[1])                                                                                                                                                       
v = random_vector(2, x=0, y=1000) 
ha3t = HA3(a-b, a-c, b-c, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-b+v[0], a-c+v[0]+v[1], b-c+v[1])                                                                                                                                                       
w = random_vector(2, x=0, y=1000) 
ha3q = HA3(a-b, a-c, b-c, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-b+v[0], a-c+v[0]+v[1], b-c+v[1], a-b+w[0], a-c+w[0]+w[1], b-c+w[1])                                                                                                                                                       
z = random_vector(2, x=0, y=1000)
ha3c = HA3(a-b, a-c, b-c, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-b+v[0], a-c+v[0]+v[1], b-c+v[1], a-b+w[0], a-c+w[0]+w[1], b-c+w[1], a-b+z[0], a-c+z[0]+z[1], b-c+z[1])                                                                                                                                                       

HA4.<a,b,c,d> = HyperplaneArrangements(QQ)                                                                                                                                                                                              
ha4 = HA4(a-b, a-c, b-c, a-d, b-d, c-d)
u = random_vector(3, x=0, y=1000)
ha4b = HA4(a-b, a-c, b-c, a-d, b-d, c-d, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-d+u[0]+u[1]+u[2], b-d+u[1]+u[2], c-d+u[2])                                                                                                                                                       
v = random_vector(3, x=0, y=1000) 
ha4t = HA4(a-b, a-c, b-c, a-d, b-d, c-d, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-d+u[0]+u[1]+u[2], b-d+u[1]+u[2], c-d+u[2], a-b+v[0], a-c+v[0]+v[1], b-c+v[1], a-d+v[0]+v[1]+v[2], b-d+v[1]+v[2], c-d+v[2])                                                                                                                                                       
w = random_vector(3, x=0, y=1000) 
ha4q = HA4(a-b, a-c, b-c, a-d, b-d, c-d, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-d+u[0]+u[1]+u[2], b-d+u[1]+u[2], c-d+u[2], a-b+v[0], a-c+v[0]+v[1], b-c+v[1], a-d+v[0]+v[1]+v[2], b-d+v[1]+v[2], c-d+v[2], a-b+w[0], a-c+w[0]+w[1], b-c+w[1], a-d+w[0]+w[1]+w[2], b-d+w[1]+w[2], c-d+w[2])                                                                                                                                                       
z = random_vector(3, x=0, y=1000)
ha4c = HA4(a-b, a-c, b-c, a-d, b-d, c-d, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-d+u[0]+u[1]+u[2], b-d+u[1]+u[2], c-d+u[2], a-b+v[0], a-c+v[0]+v[1], b-c+v[1], a-d+v[0]+v[1]+v[2], b-d+v[1]+v[2], c-d+v[2], a-b+w[0], a-c+w[0]+w[1], b-c+w[1], a-d+w[0]+w[1]+w[2], b-d+w[1]+w[2], c-d+w[2], a-b+z[0], a-c+z[0]+z[1], b-c+z[1], a-d+z[0]+z[1]+z[2], b-d+z[1]+z[2], c-d+z[2])                                                                                                                                                       

HA5.<a,b,c,d,e> = HyperplaneArrangements(QQ)
u = random_vector(4, x=0, y=1000)
ha5b = HA5(a-b, a-c, b-c, a-d, b-d, c-d, a-e, b-e, c-e, d-e, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-d+u[0]+u[1]+u[2], b-d+u[1]+u[2], c-d+u[2], a-e+u[0]+u[1]+u[2]+u[3], b-e+u[1]+u[2]+u[3], c-e+u[2]+u[3], d-e+u[3])
v = random_vector(4, x=0, y=1000) 
ha5t = HA5(a-b, a-c, b-c, a-d, b-d, c-d, a-e, b-e, c-e, d-e, a-b+u[0], a-c+u[0]+u[1], b-c+u[1], a-d+u[0]+u[1]+u[2], b-d+u[1]+u[2], c-d+u[2], a-e+u[0]+u[1]+u[2]+u[3], b-e+u[1]+u[2]+u[3], c-e+u[2]+u[3], d-e+u[3], a-b+v[0], a-c+v[0]+v[1], b-c+v[1], a-d+v[0]+v[1]+v[2], b-d+v[1]+v[2], c-d+v[2], a-e+v[0]+v[1]+v[2]+v[3], b-e+v[1]+v[2]+v[3], c-e+v[2]+v[3], d-e+v[3])


Spanning trees of hypergraphs

def complete_uniform_multipartite_hypergraph(nn):
    return IncidenceStructure(cartesian_product([range(add(nn[:i]), add(nn[:i+1])) for i in range(len(nn))]))

def spanning_hypertrees(uniform_hypergraph):
    V = uniform_hypergraph.ground_set()
    l = uniform_hypergraph.block_sizes()[0]
    if (len(V)-1) % (l-1) != 0:
        return []
    m = (len(V)-1) // (l-1)
    res = []
    for X in Subsets([tuple(B) for B in uniform_hypergraph.blocks()], m):
        H = Hypergraph(V,X)
        if not H.is_berge_cyclic():
            res.append(H)
    return res

sage: l = 3; n = 3 
....: for dd in Partitions(n*(l-1)+1, length=l, max_part=n): 
....:     print(dd, factor(len(spanning_hypertrees(complete_uniform_multipartite_hypergraph(dd))))) 
....:                                                                                                                                                                           
[3, 3, 1] 2 * 3
[3, 2, 2] 2^3 * 3
sage: l = 3; n = 4 
....: for dd in Partitions(n*(l-1)+1, length=l, max_part=n): 
....:     print(dd, factor(len(spanning_hypertrees(complete_uniform_multipartite_hypergraph(dd))))) 
....:                                                                                                                                                                           
[4, 4, 1] 2^3 * 3
[4, 3, 2] 2^5 * 3^2
[3, 3, 3] 2^5 * 3^3
sage: l = 3; n = 5 
....: for dd in Partitions(n*(l-1)+1, length=l, max_part=n): 
....:     print(dd, factor(len(spanning_hypertrees(complete_uniform_multipartite_hypergraph(dd))))) 
....:                                                                                                                                                                           
[5, 5, 1] 2^3 * 3 * 5
[5, 4, 2] 2^8 * 3 * 5
[5, 3, 3] 2^3 * 3^5 * 5
[4, 4, 3] 2^6 * 3^4 * 5

sage: [[(dd, number_faces(n, dd) * (n-dd[0]) / binomial(n, n-dd[0]-1)) for dd in IntegerVectors(n-1,3)] for n in range(1,4)]                                                    
[[([0, 0, 0], 1)],
 [([1, 0, 0], 1), ([0, 1, 0], 1), ([0, 0, 1], 1)],
 [([2, 0, 0], 1),
  ([1, 1, 0], 4),
  ([1, 0, 1], 4),
  ([0, 2, 0], 1),
  ([0, 1, 1], 6),
  ([0, 0, 2], 1)]]



Coherent diagonals

def D(n):
    return [(I,J) for k in range(1,n) for I in Subsets(range(1,n+1),k) for J in Subsets(set(range(1,n+1)).difference(I).difference(range(min(I))),k)]                                                                             

def DD(i):
    return [(I,J) for I in Subsets(range(1,2*i+1),i) for J in Subsets(set(range(1,2*i+1)).difference(I).difference(range(min(I))),i)]                                                                             

def standardize(I,J):
    U = sorted(list(I)+list(J))
    return (tuple([U.index(i)+1 for i in sorted(I)]), tuple([U.index(j)+1 for j in sorted(J)]))

@cached_function
def orientationsRec(signature):
    if len(signature) == 0:
        return (True, [],[])
    (b, orientations, specialOrientations) = orientationsRec(signature[:-1])
    if not b:
        return (False, [], [])
    orientations = orientations + [[]]
    specialOrientations = specialOrientations + [[]]
    for (I,J) in DD(len(signature)):
        foundLeft = False
        foundRight = False
        found = False
        for k in range(len(signature)//2+1):
            for I1 in Subsets(I,k):
                for J1 in Subsets(J, k):
                    if not foundLeft and standardize(I1, J1) in orientations[k-1] and standardize(I.difference(I1), J.difference(J1)) in orientations[len(signature)-k-1]:
                        orientations[-1].append((tuple(sorted(I)), tuple(sorted(J))))
                        foundLeft = True
                        found = True
                    if not foundRight and standardize(J1, I1) in orientations[k-1] and standardize(J.difference(J1), I.difference(I1)) in orientations[len(signature)-k-1]:
                        orientations[-1].append((tuple(sorted(J)), tuple(sorted(I))))
                        foundRight = True
                        found = True
        if foundLeft and foundRight:
            return (False, [], [])
        if not found:
            orientation = (tuple(sorted(I)), tuple(sorted(J))) if signature[-1] == 1 else (tuple(sorted(J)), tuple(sorted(I)))
            orientations[-1].append(orientation)
            specialOrientations[-1].append(orientation)
    assert(len(specialOrientations[-1]) <= 1)
    return (True, orientations, specialOrientations)

@cached_function
def validOrientations(n):
    if n == 0:
        return [([],[], [])]
    res = []
    for (orientations, specialOrientations, signature) in validOrientations(n-1):
        orientations = orientations + [[]]
        specialOrientations = specialOrientations + [[]]
        unoriented = []
        extendable = True
        for (I,J) in DD(n):
            foundLeft = False
            foundRight = False
            found = False
            for k in range(n//2+1):
                for I1 in Subsets(I,k):
                    for J1 in Subsets(J, k):
                        if not foundLeft and standardize(I1, J1) in orientations[k-1] and standardize(I.difference(I1), J.difference(J1)) in orientations[n-k-1]:
                            orientations[-1].append((tuple(sorted(I)), tuple(sorted(J))))
                            foundLeft = True
                            found = True
                        if not foundRight and standardize(J1, I1) in orientations[k-1] and standardize(J.difference(J1), I.difference(I1)) in orientations[n-k-1]:
                            orientations[-1].append((tuple(sorted(J)), tuple(sorted(I))))
                            foundRight = True
                            found = True
            if foundLeft and foundRight:
                extendable = False
            if not found:
                unoriented.append((tuple(sorted(I)), tuple(sorted(J))))
        assert(len(unoriented) <= 1)
        if extendable:
            if len(unoriented) == 0:
                print("no choice to be done")
                res.append((orientations, specialOrientations, signature))
            else:
                orientations2 = deepcopy(orientations)
                orientations[-1].append(unoriented[0])
                orientations2[-1].append((unoriented[0][1], unoriented[0][0]))
                specialOrientations2 = deepcopy(specialOrientations)
                specialOrientations[-1].append(unoriented[0])
                specialOrientations2[-1].append((unoriented[0][1], unoriented[0][0]))
                res = res + [(orientations, specialOrientations, signature + [1]), (orientations2, specialOrientations2, signature + [-1])]
    return res

def orientationSU(n):
    if n == 0:
        return ([],[],[])
    (orientations, specialOrientations, signature) = orientationSU(n-1)
    orientations.append([])
    specialOrientations.append([])
    for (I,J) in DD(n):
        foundLeft = False
        foundRight = False
        found = False
        for k in range(n//2+1):
            for I1 in Subsets(I,k):
                for J1 in Subsets(J, k):
                    if not found and standardize(I1, J1) in orientations[k-1] and standardize(I.difference(I1), J.difference(J1)) in orientations[n-k-1]:
                        orientations[-1].append((tuple(sorted(I)), tuple(sorted(J))))
                        foundLeft = True
                        found = True
                    if not found and standardize(J1, I1) in orientations[k-1] and standardize(J.difference(J1), I.difference(I1)) in orientations[n-k-1]:
                        orientations[-1].append((tuple(sorted(J)), tuple(sorted(I))))
                        foundRight = True
                        found = True
        assert(not foundLeft or not foundRight)
        if not found:
            orientation = (tuple(sorted(I)), tuple(sorted(J))) if max(I) > max(J) else (tuple(sorted(J)), tuple(sorted(I)))
            orientations[-1].append(orientation)
            specialOrientations[-1].append(orientation)
            signature.append(1 if min(orientation[0]) < min(orientation[1]) else -1)
    if len(specialOrientations[-1]) > 1: print(orientations, specialOrientations)
    assert(len(specialOrientations[-1]) <= 1)
    return (orientations, specialOrientations, signature)
   
Cube et simplexe :

def h_vector_diagonal(poset):
    res = defaultdict(Integer)
    for (x,y) in poset.intervals_poset():
        res[len(poset.lower_covers(x)) + len(poset.upper_covers(y))] += 1
    return res

sage: n = 2; d = h_vector_diagonal(posets.BooleanLattice(n)); [add(binomial(l,k) * d[l] for l in range(n+1)) for k in range(n+1)]                                                                                                          
[9, 12, 4]
sage: n = 3; d = h_vector_diagonal(posets.BooleanLattice(n)); [add(binomial(l,k) * d[l] for l in range(n+1)) for k in range(n+1)]                                                                                                          
[27, 54, 36, 8]
sage: n = 4; d = h_vector_diagonal(posets.BooleanLattice(n)); [add(binomial(l,k) * d[l] for l in range(n+1)) for k in range(n+1)]                                                                                                          
[81, 216, 216, 96, 16]
